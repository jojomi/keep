// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package keep

import (
	"fmt"
	"strings"
)

const (
	// LAST is a TimeRange of type LAST.
	LAST TimeRange = iota
	// SECOND is a TimeRange of type SECOND.
	SECOND
	// MINUTE is a TimeRange of type MINUTE.
	MINUTE
	// HOUR is a TimeRange of type HOUR.
	HOUR
	// DAY is a TimeRange of type DAY.
	DAY
	// WEEK is a TimeRange of type WEEK.
	WEEK
	// MONTH is a TimeRange of type MONTH.
	MONTH
	// QUARTER is a TimeRange of type QUARTER.
	QUARTER
	// YEAR is a TimeRange of type YEAR.
	YEAR
	// DECADE is a TimeRange of type DECADE.
	DECADE
	// CENTURY is a TimeRange of type CENTURY.
	CENTURY
	// MILLENIUM is a TimeRange of type MILLENIUM.
	MILLENIUM
)

const _TimeRangeName = "LASTSECONDMINUTEHOURDAYWEEKMONTHQUARTERYEARDECADECENTURYMILLENIUM"

var _TimeRangeNames = []string{
	_TimeRangeName[0:4],
	_TimeRangeName[4:10],
	_TimeRangeName[10:16],
	_TimeRangeName[16:20],
	_TimeRangeName[20:23],
	_TimeRangeName[23:27],
	_TimeRangeName[27:32],
	_TimeRangeName[32:39],
	_TimeRangeName[39:43],
	_TimeRangeName[43:49],
	_TimeRangeName[49:56],
	_TimeRangeName[56:65],
}

// TimeRangeNames returns a list of possible string values of TimeRange.
func TimeRangeNames() []string {
	tmp := make([]string, len(_TimeRangeNames))
	copy(tmp, _TimeRangeNames)
	return tmp
}

var _TimeRangeMap = map[TimeRange]string{
	LAST:      _TimeRangeName[0:4],
	SECOND:    _TimeRangeName[4:10],
	MINUTE:    _TimeRangeName[10:16],
	HOUR:      _TimeRangeName[16:20],
	DAY:       _TimeRangeName[20:23],
	WEEK:      _TimeRangeName[23:27],
	MONTH:     _TimeRangeName[27:32],
	QUARTER:   _TimeRangeName[32:39],
	YEAR:      _TimeRangeName[39:43],
	DECADE:    _TimeRangeName[43:49],
	CENTURY:   _TimeRangeName[49:56],
	MILLENIUM: _TimeRangeName[56:65],
}

// String implements the Stringer interface.
func (x TimeRange) String() string {
	if str, ok := _TimeRangeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("TimeRange(%d)", x)
}

var _TimeRangeValue = map[string]TimeRange{
	_TimeRangeName[0:4]:                    LAST,
	strings.ToLower(_TimeRangeName[0:4]):   LAST,
	_TimeRangeName[4:10]:                   SECOND,
	strings.ToLower(_TimeRangeName[4:10]):  SECOND,
	_TimeRangeName[10:16]:                  MINUTE,
	strings.ToLower(_TimeRangeName[10:16]): MINUTE,
	_TimeRangeName[16:20]:                  HOUR,
	strings.ToLower(_TimeRangeName[16:20]): HOUR,
	_TimeRangeName[20:23]:                  DAY,
	strings.ToLower(_TimeRangeName[20:23]): DAY,
	_TimeRangeName[23:27]:                  WEEK,
	strings.ToLower(_TimeRangeName[23:27]): WEEK,
	_TimeRangeName[27:32]:                  MONTH,
	strings.ToLower(_TimeRangeName[27:32]): MONTH,
	_TimeRangeName[32:39]:                  QUARTER,
	strings.ToLower(_TimeRangeName[32:39]): QUARTER,
	_TimeRangeName[39:43]:                  YEAR,
	strings.ToLower(_TimeRangeName[39:43]): YEAR,
	_TimeRangeName[43:49]:                  DECADE,
	strings.ToLower(_TimeRangeName[43:49]): DECADE,
	_TimeRangeName[49:56]:                  CENTURY,
	strings.ToLower(_TimeRangeName[49:56]): CENTURY,
	_TimeRangeName[56:65]:                  MILLENIUM,
	strings.ToLower(_TimeRangeName[56:65]): MILLENIUM,
}

// ParseTimeRange attempts to convert a string to a TimeRange.
func ParseTimeRange(name string) (TimeRange, error) {
	if x, ok := _TimeRangeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _TimeRangeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return TimeRange(0), fmt.Errorf("%s is not a valid TimeRange, try [%s]", name, strings.Join(_TimeRangeNames, ", "))
}

// MustParseTimeRange converts a string to a TimeRange, and panics if is not valid.
func MustParseTimeRange(name string) TimeRange {
	val, err := ParseTimeRange(name)
	if err != nil {
		panic(err)
	}
	return val
}
